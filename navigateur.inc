<?php
/*
 * Copyright (c) 2005-2007,2009,2014-2015,2021 Guillaume Outters
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

require_once dirname(__FILE__).'/params.inc';

/* Merci aux notes de bas de page sur php.net! */
if (!function_exists('iconv') && function_exists('libiconv')) { function iconv($input_encoding, $output_encoding, $string) { return libiconv($input_encoding, $output_encoding, $string); } }

/* Simule un navigateur web: retient l'√©tat cookies, referer, derni√®re URL
 * absolue pour calculer les relatives. */

class Navigateur
{
	const NOTICE = 0x10;
	const INFO = 0x08;
	
	function effacerCookies() { $this->cookies = array(); $this->cookiesTasses = null; }
	function __construct() { $this->derniere = null; $this->effacerCookies(); $this->donn√©es = array(); }
	
	function tasserCookies($url)
	{
		/* Consolidation des traceurs concern√©s. */
		
		if(preg_match('#^https?://([^/]*)#', $url, /*&*/ $r√©s))
			$domaineActuel = $r√©s[1];
		$traceurs = [];
		foreach($this->cookies as $domaine => $traceursDomaine)
			if($domaine == $domaineActuel) /* √Ä FAIRE: g√©rer les multi-domaines. */
				/* √Ä FAIRE: filtrer aussi sur le chemin. */
				$traceurs += $traceursDomaine;
		
		/* S√©rialisation. */
		
		$noms = array_keys($traceurs);
		$n = count($noms) - 1;
		if($n < 0) { $this->cookiesTasses = null; return; }
		$this->cookiesTasses = array();
		foreach($traceurs as $cl√© => $val)
			$this->cookiesTasses[] = $cl√©.'='.$val;
		$this->cookiesTasses = implode('; ', $this->cookiesTasses);
	}
	
	/* Calcule l'URL absolue atteinte depuis le n≈ìud courant en attaquant une
	 * URL absolue, relative ou racine. */
	function url($url = null)
	{
		if($url === null)
			return $this->derniere;
			if(substr($url, 0, 1) == '/') // URL absolue sur le m√™me site.
			{
				$pos = strpos($this->derniere, '/', strpos($this->derniere, '://') + 3);
				return ($pos === false ? $this->derniere : substr($this->derniere, 0, $pos)).$url;
			}
			else if(strpos($url, 'http://') !== 0 && strpos($url, 'https://') !== 0) // URL relative
			{
				if(($pos = strrpos($this->derniere, '/')) != 0)
					return substr($this->derniere, 0, $pos + 1).$url;
			}
			if(preg_match('#^https?://[^/]*$#', $url))
				$url = $url.'/';
			return $url;
	}
	
	protected function _diag($niveau, $message)
	{
		$couls = array
		(
			Navigateur::NOTICE => 36,
		);
		fprintf(STDERR, "[%dm%s[0m%s", isset($couls[$niveau]) ? $couls[$niveau] : 0, $message, substr($message, -1) == "\n" ? '' : "\n");
	}
	
	/* R√©cup√®re une URL.
	 * Param√®tres:
	 *   url: URL √† obtenir
	 *   champs: tableau associatif envoy√© en POST
	 *   continuer: si true, le Navigateur est mis-√†-jour avec les nouvelles
	 *     infos collect√©es.
	 */
	function obtenir($url, $champs = null, $continuer = false, $enTetesHttp = null)
	{
		$this->suivre = $url;
		$this->continuer = $continuer;
		
		while($this->suivre !== null) // On suit les Location: √† la main, car sinon nos cookies re√ßus dans une r√©ponse contenant √† la fois un Location et un Set-Cookie ne sont pas pris en compte au fur et √† mesure. Couillon de PHP ou de curl. /* √Ä FAIRE?: r√©cup√©rer la connexion au lieu de faire des curl_init()/curl_close() √† chaque fois. */
		{
			$url = $this->suivre;
			$this->suivre = null;
			
			$c = curl_init();
			if($this->derniere) curl_setopt($c, CURLOPT_REFERER, $this->derniere);
			//curl_setopt($c, CURLOPT_FOLLOWLOCATION, true);
			//curl_setopt($c, CURLOPT_MAXREDIRS, 0x8);
			curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
			$url = $this->url($url);
			curl_setopt($c, CURLOPT_URL, $url);
			$this->tasserCookies($url);
			curl_setopt($c, CURLOPT_COOKIE, $this->cookiesTasses);
			if($this->cookiesTasses)
			$this->_diag(0, $this->cookiesTasses);
			if($champs !== null)
			{
				/* √áa on vire, c'est d√©j√† fait par params_decomposer (√† part la conversion en latin1. Peut-√™tre un param√®tre √† rajouter?).
				foreach($champs as $cle => $valeur)
					if(!is_array($valeur))
						$champs[$cle] = urlencode(iconv('UTF-8', 'ISO-8859-1//IGNORE', $valeur)); // √Ä FAIRE: ne pas coder en dur cette salet√© d'ISO-8859-1 (qui n'accepte m√™me pas mon pasœÑŒµœá); d√©pendre des directives du formulaire rempli. *//* √Ä FAIRE: rentrer r√©cursivement dans les tableaux.
				*/
				/* PHP est bourrin, il poste en multipart si $champs est un tableau.
				 * √áa ne nous pla√Æt pas du tout, enfin nous si, mais pas Monster
				 * pour l'authentification. */
				$this->_diag(Navigateur::NOTICE, 'POST '.substr($url, 0, 1024)."\n".print_r($champs, true));
				$champs = is_string($champs) ? $champs : substr(params_decomposer(null, $champs), 1);
				curl_setopt($c, CURLOPT_POSTFIELDS, $champs);
			}
			else
				$this->_diag(Navigateur::NOTICE, 'GET '.substr($url, 0, 1024));
			$GLOBALS['navigateur_recuperateurEnTetes'] = &$this;
			curl_setopt($c, CURLOPT_HEADERFUNCTION, 'navigateur_recupEnTete');
			curl_setopt($c, CURLOPT_SSL_VERIFYPEER, false);
			if(isset($this->auth))
			{
				curl_setopt($c, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
				curl_setopt($c, CURLOPT_USERPWD, $this->auth); // id:mdp
			}
			if(isset($enTetesHttp))
			{
				$ent = array();
				foreach($enTetesHttp as $cl√© => $valeur)
					$ent[] = is_int($cl√©) ? $valeur : $cl√©.': '.$valeur;
				curl_setopt($c, CURLOPT_HTTPHEADER, $ent);
			}
			if($this->continuer)
				$this->derniere = $url;
			$r = curl_exec($c);
			$this->retour = curl_getinfo($c, CURLINFO_HTTP_CODE);
			curl_close($c);
			
			if(!$this->suivreLocations)
				return $r;
			
			/* Pour continuer (redirection) */
			
			$champs = null;
		}
		
		return $r;
	}
	
	function aller($url, $champs = null) { return $this->obtenir($url, $champs, true); }
	
	function allerEtTrouver($url, $champs, $comment√áaSAppelle, $trouver)
	{
		$page = $this->page = $this->aller($url, $champs);
		$r = preg_match($trouver, $page, $r√©ponses, 0);
		if(!$r) { echo '# Impossible de r√©cup√©rer '.$comment√áaSAppelle.'.'."\n"; return false; }
		return $r√©ponses[1];
	}
	
	function recupererEnTete($enTete)
	{
		if(preg_match('#^https?://([^/]*)#', $this->derniere, /*&*/ $r√©s))
			$domaine = $r√©s[1];
		if($this->continuer && (strpos($enTete, 'Set-Cookie: ') === 0))
		{
			$ligne = trim(substr($enTete, 0xc));
			preg_match_all('# *([^=]*)=(([^"][^;]*)|("[^"]*"));#', $ligne.';', $r√©s);
			$nom = $r√©s[1][0];
			$val = $r√©s[4][0] !== '' ? $r√©s[4][0] : $r√©s[3][0];
			for($i = count($r√©s[1]); --$i >= 1;)
				if($r√©s[1][$i] == 'Expires')
				{
					if(strpos($r√©s[2][$i], '-1970') !== false)
					{
						unset($this->cookies[$domaine][$nom]);
						return;
					}
				}
			$this->cookies[$domaine][$nom] = $val;
		}
		// √Ä FAIRE: la raison d'√™tre de cette fonction ne serait-elle pas CURLINFO_EFFECTIVE_URL?
		else if(strpos($enTete, 'Location: ') === 0 || strpos($enTete, 'location: ') === 0) // Sale con d'IIS de photoservice.com!
			$this->suivre = strtr(substr($enTete, 0xa), array("\n" => '', "\r" => '')); // Un caract√®re retour √† la fin.
	}
	
	function rattacherALaSession(&$session)
	{
		if(is_array($session))
		{
			$this->derniere = &$session['derniere'];
			$this->cookies = &$session['cookies'];
			$this->donn√©es = &$session['donn√©es'];
		}
		else
		{
			$session['derniere'] = &$this->derniere;
			$session['cookies'] = &$this->cookies;
			$session['donn√©es'] = &$this->donn√©es;
		}
	}
	
	function cloner()
	{
		$nouveau = clone $this;
		
		unset($nouveau->donn√©es); $nouveau->donn√©es = array(); // C'est une r√©f√©rence (sur un objet de session), donc en clonant c'est toujours une r√©f√©rence sur le m√™me; seul l'unset permettra √† chacun des deux objets de poursuivre son bonhomme de chemin.
		unset($nouveau->cookies); $nouveau->cookies = $this->cookies;
		unset($nouveau->derniere); $nouveau->derniere = $this->derniere;
		
		return $nouveau;
	}
	
	public $retour;
	public $page;
	public $jeton;
	public $continuer;
	public $cookiesTasses;
	
	protected $derniere;
	protected $cookies;
	public $donn√©es; // Donn√©es suppl√©mentaires attach√©es √† la session, laiss√©es √† la discr√©tion de l'utilisateur (ex.: r√©sultat de l'interpr√©tation de la page charg√©e).
	protected $suivre; // √âtat: a-t-on re√ßu un Location: dans la derni√®re r√©ponse?
	public $suivreLocations = true;
}

function navigateur_recupEnTete($curl, $enTete)
{
	$GLOBALS['navigateur_recuperateurEnTetes']->recupererEnTete($enTete);
	return strlen($enTete);
}

/* Plusieurs Navigateurs retenus en session */

class NavigateurHi√©rarchique
{
	protected $navigo; // Pile de Navigateurs
	protected $explo; // Pointeur sur le petit dernier de $navigo.
	protected $stockage; // √âl√©ment de $_SESSION dans lequel on nous a donn√© carte blanche.
	
	/* Rattache le NavigateurHi√©rarchique √† une session (√† cr√©er ou existante).
	 * Param√®tres:
	 *   $o√π: tableau indiquant le chemin √† suivre dans $_SESSION pour arriver √†
	 *     l'espace r√©serv√© au stockage du NavigateurHi√©rarchique. */
	function pr√©parerSession($o√π)
	{
		$this->navigo = array(); // PHP outrepassant tout ce qu'un esprit malade pourrait concevoir en mati√®re de langage merdique √† souhait, on ne peut pas s√©rialiser notre Navigateur dans la session car celle-ci est d√©roul√©e par un truc (de_session) qui y cherche ses r√©glages, alors que ce fichier (et donc la classe Navigateur) n'a pas encore √©t√© charg√©e, ce qui vautre PHP. On ne s√©rialise donc que le contenu du Navigateur, qu'on se fait chier ensuite √† remettre en place √† la main ici. Mais qu'est-ce qu'ils sont cons, alors!
		$this->stockage = &$_SESSION;
		foreach($o√π as $√©l√©ment)
		{
			if(!array_key_exists($√©l√©ment, $this->stockage))
				$this->stockage[$√©l√©ment] = array();
			$this->stockage = &$this->stockage[$√©l√©ment];
		}
		$i = count($this->stockage);
		if($i <= 0) $i = 1;
		while(--$i >= 0)
			$this->ajouterOuRecup√©rerDernierNavigo();
	}
	
	function ajouterOuRecup√©rerDernierNavigo()
	{
		$i = count($this->navigo);
		$this->navigo[$i] = $i == 0 ? new Navigateur() : $this->navigo[$i - 1]->cloner();
		$this->explo = &$this->navigo[$i];
		$this->explo->donn√©es['pos'] = 0;
		$this->explo->rattacherALaSession($this->stockage[$i]);
	}
	
	function supprimerDernierNavigo()
	{
		$i = count($this->navigo) - 1;
		if($i > 0)
			$this->explo = &$this->navigo[$i - 1];
		else
			$this->explo = null;
		array_splice($this->navigo, $i);
		array_splice($this->stockage, $i);
	}
}

?>