<?php
/*
 * Copyright (c) 2005-2007,2009,2014-2015,2021 Guillaume Outters
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

require_once dirname(__FILE__).'/params.inc';

/* Merci aux notes de bas de page sur php.net! */
if (!function_exists('iconv') && function_exists('libiconv')) { function iconv($input_encoding, $output_encoding, $string) { return libiconv($input_encoding, $output_encoding, $string); } }

/* Simule un navigateur web: retient l'Ã©tat cookies, referer, derniÃ¨re URL
 * absolue pour calculer les relatives. */

class Navigateur
{
	const NOTICE = 0x10;
	const INFO = 0x08;
	
	function effacerCookies() { $this->cookies = array(); $this->cookiesTasses = null; }
	function __construct() { $this->derniere = null; $this->effacerCookies(); $this->donnÃ©es = array(); }
	
	function tasserCookies()
	{
		$noms = array_keys($this->cookies);
		$n = count($noms) - 1;
		if($n < 0) { $this->cookiesTasses = null; return; }
		$this->cookiesTasses = array();
		foreach($this->cookies as $clÃ© => $val)
			$this->cookiesTasses[] = $clÃ©.'='.$val;
		$this->cookiesTasses = implode('; ', $this->cookiesTasses);
	}
	
	/* Calcule l'URL absolue atteinte depuis le nÅ“ud courant en attaquant une
	 * URL absolue, relative ou racine. */
	function url($url = null)
	{
		if($url === null)
			return $this->derniere;
			if($url{0} == '/') // URL absolue sur le mÃªme site.
			{
				$pos = strpos($this->derniere, '/', strpos($this->derniere, '://') + 3);
				return ($pos === false ? $this->derniere : substr($this->derniere, 0, $pos)).$url;
			}
			else if(strpos($url, 'http://') !== 0 && strpos($url, 'https://') !== 0) // URL relative
			{
				if(($pos = strrpos($this->derniere, '/')) != 0)
					return substr($this->derniere, 0, $pos + 1).$url;
			}
			if(preg_match('#^http://[^/]*$#', $url))
				$url = $url.'/';
			return $url;
	}
	
	protected function _diag($niveau, $message)
	{
		$couls = array
		(
			Navigateur::NOTICE => 36,
		);
		fprintf(STDERR, "[%dm%s[0m%s", isset($couls[$niveau]) ? $couls[$niveau] : 0, $message, substr($message, -1) == "\n" ? '' : "\n");
	}
	
	/* RÃ©cupÃ¨re une URL.
	 * ParamÃ¨tres:
	 *   url: URL Ã  obtenir
	 *   champs: tableau associatif envoyÃ© en POST
	 *   continuer: si true, le Navigateur est mis-Ã -jour avec les nouvelles
	 *     infos collectÃ©es.
	 */
	function obtenir($url, $champs = null, $continuer = false, $enTetesHttp = null)
	{
		$this->suivre = $url;
		$this->continuer = $continuer;
		
		while($this->suivre !== null) // On suit les Location: Ã  la main, car sinon nos cookies reÃ§us dans une rÃ©ponse contenant Ã  la fois un Location et un Set-Cookie ne sont pas pris en compte au fur et Ã  mesure. Couillon de PHP ou de curl. /* Ã€ FAIRE?: rÃ©cupÃ©rer la connexion au lieu de faire des curl_init()/curl_close() Ã  chaque fois. */
		{
			$url = $this->suivre;
			$this->suivre = null;
			
			$c = curl_init();
			if($this->derniere) curl_setopt($c, CURLOPT_REFERER, $this->derniere);
			//curl_setopt($c, CURLOPT_FOLLOWLOCATION, true);
			//curl_setopt($c, CURLOPT_MAXREDIRS, 0x8);
			curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
			$url = $this->url($url);
			curl_setopt($c, CURLOPT_URL, $url);
			curl_setopt($c, CURLOPT_COOKIE, $this->cookiesTasses);
			$this->_diag(0, $this->cookiesTasses);
			if($champs !== null)
			{
				/* Ã‡a on vire, c'est dÃ©jÃ  fait par params_decomposer (Ã  part la conversion en latin1. Peut-Ãªtre un paramÃ¨tre Ã  rajouter?).
				foreach($champs as $cle => $valeur)
					if(!is_array($valeur))
						$champs[$cle] = urlencode(iconv('UTF-8', 'ISO-8859-1//IGNORE', $valeur)); // Ã€ FAIRE: ne pas coder en dur cette saletÃ© d'ISO-8859-1 (qui n'accepte mÃªme pas mon pasÏ„ÎµÏ‡); dÃ©pendre des directives du formulaire rempli. *//* Ã€ FAIRE: rentrer rÃ©cursivement dans les tableaux.
				*/
				/* PHP est bourrin, il poste en multipart si $champs est un tableau.
				 * Ã‡a ne nous plaÃ®t pas du tout, enfin nous si, mais pas Monster
				 * pour l'authentification. */
				$this->_diag(Navigateur::NOTICE, 'POST '.substr($url, 0, 1024)."\n".print_r($champs, true));
				$champs = is_string($champs) ? $champs : substr(params_decomposer(null, $champs), 1);
				curl_setopt($c, CURLOPT_POSTFIELDS, $champs);
			}
			else
				$this->_diag(Navigateur::NOTICE, 'GET '.substr($url, 0, 1024));
			$GLOBALS['navigateur_recuperateurEnTetes'] = &$this;
			curl_setopt($c, CURLOPT_HEADERFUNCTION, 'navigateur_recupEnTete');
			curl_setopt($c, CURLOPT_SSL_VERIFYPEER, false);
			if(isset($this->auth))
			{
				curl_setopt($c, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
				curl_setopt($c, CURLOPT_USERPWD, $this->auth); // id:mdp
			}
			if(isset($enTetesHttp))
				curl_setopt($c, CURLOPT_HTTPHEADER, $enTetesHttp);
			if($this->continuer)
				$this->derniere = $url;
			$r = curl_exec($c);
			$this->retour = curl_getinfo($c, CURLINFO_HTTP_CODE);
			curl_close($c);
			$this->tasserCookies();
			
			if(!$this->suivreLocations)
				return $r;
			
			/* Pour continuer (redirection) */
			
			$champs = null;
		}
		
		return $r;
	}
	
	function aller($url, $champs = null) { return $this->obtenir($url, $champs, true); }
	
	function allerEtTrouver($url, $champs, $commentÃ‡aSAppelle, $trouver)
	{
		$page = $this->page = $this->aller($url, $champs);
		$r = preg_match($trouver, $page, $rÃ©ponses, 0);
		if(!$r) { echo '# Impossible de rÃ©cupÃ©rer '.$commentÃ‡aSAppelle.'.'."\n"; return false; }
		return $rÃ©ponses[1];
	}
	
	function recupererEnTete($enTete)
	{
		if($this->continuer && (strpos($enTete, 'Set-Cookie: ') === 0))
		{
			$ligne = trim(substr($enTete, 0xc));
			preg_match_all('# *([^=]*)=(([^"][^;]*)|("[^"]*"));#', $ligne.';', $rÃ©s);
			$nom = $rÃ©s[1][0];
			$val = $rÃ©s[4][0] !== '' ? $rÃ©s[4][0] : $rÃ©s[3][0];
			for($i = count($rÃ©s[1]); --$i >= 1;)
				if($rÃ©s[1][$i] == 'Expires')
				{
					if(strpos($rÃ©s[2][$i], '-1970') !== false)
					{
						unset($this->cookies[$nom]);
						return;
					}
				}
			$this->cookies[$nom] = $val;
		}
		// Ã€ FAIRE: la raison d'Ãªtre de cette fonction ne serait-elle pas CURLINFO_EFFECTIVE_URL?
		else if(strpos($enTete, 'Location: ') === 0 || strpos($enTete, 'location: ') === 0) // Sale con d'IIS de photoservice.com!
			$this->suivre = strtr(substr($enTete, 0xa), array("\n" => '', "\r" => '')); // Un caractÃ¨re retour Ã  la fin.
	}
	
	function rattacherALaSession(&$session)
	{
		if(is_array($session))
		{
			$this->derniere = &$session['derniere'];
			$this->cookies = &$session['cookies'];
			$this->donnÃ©es = &$session['donnÃ©es'];
			$this->tasserCookies();
		}
		else
		{
			$session['derniere'] = &$this->derniere;
			$session['cookies'] = &$this->cookies;
			$session['donnÃ©es'] = &$this->donnÃ©es;
		}
	}
	
	function cloner()
	{
		$nouveau = clone $this;
		
		unset($nouveau->donnÃ©es); $nouveau->donnÃ©es = array(); // C'est une rÃ©fÃ©rence (sur un objet de session), donc en clonant c'est toujours une rÃ©fÃ©rence sur le mÃªme; seul l'unset permettra Ã  chacun des deux objets de poursuivre son bonhomme de chemin.
		unset($nouveau->cookies); $nouveau->cookies = $this->cookies;
		unset($nouveau->derniere); $nouveau->derniere = $this->derniere;
		
		return $nouveau;
	}
	
	protected $derniere;
	protected $cookies;
	public $donnÃ©es; // DonnÃ©es supplÃ©mentaires attachÃ©es Ã  la session, laissÃ©es Ã  la discrÃ©tion de l'utilisateur (ex.: rÃ©sultat de l'interprÃ©tation de la page chargÃ©e).
	protected $suivre; // Ã‰tat: a-t-on reÃ§u un Location: dans la derniÃ¨re rÃ©ponse?
	public $suivreLocations = true;
}

function navigateur_recupEnTete($curl, $enTete)
{
	$GLOBALS['navigateur_recuperateurEnTetes']->recupererEnTete($enTete);
	return strlen($enTete);
}

/* Plusieurs Navigateurs retenus en session */

class NavigateurHiÃ©rarchique
{
	protected $navigo; // Pile de Navigateurs
	protected $explo; // Pointeur sur le petit dernier de $navigo.
	protected $stockage; // Ã‰lÃ©ment de $_SESSION dans lequel on nous a donnÃ© carte blanche.
	
	/* Rattache le NavigateurHiÃ©rarchique Ã  une session (Ã  crÃ©er ou existante).
	 * ParamÃ¨tres:
	 *   $oÃ¹: tableau indiquant le chemin Ã  suivre dans $_SESSION pour arriver Ã 
	 *     l'espace rÃ©servÃ© au stockage du NavigateurHiÃ©rarchique. */
	function prÃ©parerSession($oÃ¹)
	{
		$this->navigo = array(); // PHP outrepassant tout ce qu'un esprit malade pourrait concevoir en matiÃ¨re de langage merdique Ã  souhait, on ne peut pas sÃ©rialiser notre Navigateur dans la session car celle-ci est dÃ©roulÃ©e par un truc (de_session) qui y cherche ses rÃ©glages, alors que ce fichier (et donc la classe Navigateur) n'a pas encore Ã©tÃ© chargÃ©e, ce qui vautre PHP. On ne sÃ©rialise donc que le contenu du Navigateur, qu'on se fait chier ensuite Ã  remettre en place Ã  la main ici. Mais qu'est-ce qu'ils sont cons, alors!
		$this->stockage = &$_SESSION;
		foreach($oÃ¹ as $Ã©lÃ©ment)
		{
			if(!array_key_exists($Ã©lÃ©ment, $this->stockage))
				$this->stockage[$Ã©lÃ©ment] = array();
			$this->stockage = &$this->stockage[$Ã©lÃ©ment];
		}
		$i = count($this->stockage);
		if($i <= 0) $i = 1;
		while(--$i >= 0)
			$this->ajouterOuRecupÃ©rerDernierNavigo();
	}
	
	function ajouterOuRecupÃ©rerDernierNavigo()
	{
		$i = count($this->navigo);
		$this->navigo[$i] = $i == 0 ? new Navigateur() : $this->navigo[$i - 1]->cloner();
		$this->explo = &$this->navigo[$i];
		$this->explo->donnÃ©es['pos'] = 0;
		$this->explo->rattacherALaSession($this->stockage[$i]);
	}
	
	function supprimerDernierNavigo()
	{
		$i = count($this->navigo) - 1;
		if($i > 0)
			$this->explo = &$this->navigo[$i - 1];
		else
			$this->explo = null;
		array_splice($this->navigo, $i);
		array_splice($this->stockage, $i);
	}
}

?>